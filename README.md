# Домашнее задание: Iterators. Generators. Yield

## Описание задания

Данное домашнее задание направлено на изучение и практическое применение итераторов и генераторов в Python. Необходимо реализовать классы и функции для работы с вложенными списками, создав их плоское представление.

## Структура проекта

```
Iterators_Generators_Yield_NetologyDZ/
├── main.py              # Основной файл с реализацией всех заданий
├── requirements.txt     # Зависимости проекта
├── .gitignore          # Исключения для Git
├── README.md           # Данный файл с описанием
└── venv/               # Виртуальное окружение (создается автоматически)
```

## Задания

### Задание 1: Класс FlatIterator
Реализовать класс `FlatIterator`, который принимает список списков и возвращает их плоское представление. Итератор должен обрабатывать двухуровневую вложенность.

**Особенности реализации:**
- Использование методов `__iter__()` и `__next__()`
- Отслеживание текущей позиции в основном списке и подсписке
- Корректная обработка `StopIteration`

### Задание 2: Функция flat_generator
Реализовать функцию `flat_generator`, которая является генератором и выполняет ту же задачу, что и `FlatIterator`.

**Особенности реализации:**
- Использование ключевого слова `yield`
- Ленивая загрузка элементов
- Возврат объекта типа `GeneratorType`

### Задание 3: Рекурсивный FlatIterator (необязательное)
Создать итератор, способный обрабатывать списки с любым уровнем вложенности.

**Особенности реализации:**
- Рекурсивный метод `_flatten_recursive()` для разворачивания вложенности
- Предварительное создание плоского списка
- Поддержка произвольной глубины вложенности

### Задание 4: Рекурсивный flat_generator (необязательное)
Создать генератор, способный обрабатывать списки с любым уровнем вложенности.

**Особенности реализации:**
- Рекурсивное использование `yield from`
- Ленивая загрузка даже для глубоко вложенных структур
- Эффективное использование памяти

## Технические детали

### Использованные концепции Python:

1. **Итераторы:**
   - Протокол итерации (`__iter__`, `__next__`)
   - Обработка исключения `StopIteration`
   - Состояние итератора
   - Создание пользовательских итераторов

2. **Генераторы:**
   - Ключевое слово `yield`
   - Ленивые вычисления
   - `yield from` для делегирования
   - Генераторные выражения `(x for x in iterable)`
   - Методы `send()`, `throw()`, `close()`

3. **Генераторные выражения:**
   - Компактный синтаксис создания генераторов
   - Условные выражения в генераторах
   - Эффективность памяти

4. **itertools модуль:**
   - `chain()` - объединение итераторов
   - `cycle()` - бесконечные циклы
   - `islice()` - срезы итераторов
   - `combinations()` - комбинации элементов

5. **Контекстные менеджеры:**
   - `@contextmanager` декоратор
   - Генераторы как контекстные менеджеры
   - `try/finally` блоки в генераторах

6. **Рекурсия:**
   - Рекурсивные алгоритмы
   - Обработка вложенных структур данных
   - Проверка типов с помощью `isinstance()`

7. **Тестирование:**
   - Модуль `types` для проверки типа генератора
   - Утверждения `assert` для валидации
   - Функция `zip()` для сравнения результатов

8. **Эффективность памяти:**
   - Сравнение списков и генераторов
   - `sys.getsizeof()` для измерения памяти
   - Ленивая загрузка данных

### Алгоритмическая сложность:

- **Простые версии (задания 1-2):** O(n), где n - общее количество элементов
- **Рекурсивные версии (задания 3-4):** O(n), где n - общее количество элементов
- **Пространственная сложность:** O(d) для рекурсивных версий, где d - глубина вложенности

## Установка и запуск

### 1. Создание виртуального окружения:
```bash
python3 -m venv venv
```

### 2. Активация виртуального окружения:
```bash
# На macOS/Linux:
source venv/bin/activate

# На Windows:
venv\Scripts\activate
```

### 3. Установка зависимостей:
```bash
pip install -r requirements.txt
```

### 4. Запуск программы:
```bash
python main.py
```

## Примеры использования

### Основные задания:

**Простой итератор:**
```python
list_of_lists = [['a', 'b'], ['c', 'd']]
for item in FlatIterator(list_of_lists):
    print(item)  # Выведет: a, b, c, d
```

**Простой генератор:**
```python
list_of_lists = [['a', 'b'], ['c', 'd']]
for item in flat_generator(list_of_lists):
    print(item)  # Выведет: a, b, c, d
```

**Рекурсивные версии:**
```python
complex_list = [[['a'], ['b', 'c']], ['d', [['e']]]]
for item in RecursiveFlatIterator(complex_list):
    print(item)  # Выведет: a, b, c, d, e
```

### Дополнительные изученные концепции:

**Генераторные выражения:**
```python
# Обычный генератор
def squares(n):
    for i in range(n):
        yield i ** 2

# Генераторное выражение (аналогично)
squares_gen = (i ** 2 for i in range(5))

# С условием
even_squares = (i ** 2 for i in range(10) if i % 2 == 0)
```

**itertools модуль:**
```python
import itertools

# Объединение итераторов
chained = itertools.chain([1, 2], [3, 4])

# Бесконечный цикл
cycle_iter = itertools.cycle(['A', 'B', 'C'])

# Срез итератора
sliced = itertools.islice(range(20), 5, 15, 2)
```

**Контекстные менеджеры с генераторами:**
```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("Начало")
    try:
        yield "Контекст активен"
    finally:
        print("Конец")

with my_context() as ctx:
    print(f"Работаем: {ctx}")
```

**Продвинутые возможности yield:**
```python
def data_processor(data):
    for item in data:
        feedback = yield item  # Получаем данные от вызывающего кода
        if feedback:
            print(f"Обработано: {feedback}")

processor = data_processor([1, 2, 3])
next(processor)  # Получаем 1
processor.send("processed")  # Отправляем обратно
```

## Результаты тестирования

Все тесты проходят успешно:
- ✅ Задание 1: FlatIterator
- ✅ Задание 2: flat_generator  
- ✅ Задание 3: RecursiveFlatIterator
- ✅ Задание 4: recursive_flat_generator

## Ключевые особенности решения

1. **Чистый код:** Все классы и функции хорошо документированы
2. **Тестирование:** Включены автоматические тесты для всех заданий
3. **Демонстрация:** Добавлена функция показа работы всех реализаций
4. **Обработка ошибок:** Корректная обработка граничных случаев
5. **Производительность:** Эффективные алгоритмы без избыточных вычислений

## Изученные темы

- Протокол итерации в Python
- Различия между итераторами и генераторами
- Рекурсивные алгоритмы
- Ленивые вычисления
- Обработка вложенных структур данных
- Тестирование кода с помощью assert
- Работа с типами данных в Python

## Заключение

Данное задание позволило изучить основы работы с итераторами и генераторами в Python, а также освоить рекурсивные алгоритмы для обработки сложных структур данных. Реализованные решения демонстрируют различные подходы к решению одной задачи и показывают преимущества каждого из них.
